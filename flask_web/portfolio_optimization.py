# -*- coding: utf-8 -*-
"""Copy of 5th draft.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xMfctoGsDpb3blacBxPHjXnO0y8PUpmh
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


class IndicatorAnalyst():
  """The class contains functions to store currency data and analyze currency pairs based on technical indicators by showing plot and returns
    Use historical data to generate future signal
    There are 3 actions based on signal: buy when signal = 1, sell when signal = -1, hold when signal = 0

    Attributes:
        indicators: technical indicators used to analyze
        cur_pair: name of the currency pair.
    """
  __indicators = {'cci','macd', 'ema', 'rsi', 'stochrsi','supertrend','sma', 'wma' , 'vwap'}
  __cur_pair = ""
  __db_conn = None

  def __init__(self):
    self.df = pd.DataFrame()
    self.__indicators = {
        'cci' : self.cci,
        'macd': self.macd,
        'ema' : self.ema,
        'rsi' : self.rsi,
        'stochrsi' : self.stochrsi,
        'supertrend' : self.supertrend,
        'sma' : self.sma,
        'wma' : self.wma,
        'vwap': self.vwap}


    # Indicator: get the following indicators for the process
  def get_indicators(self):
    return self.__indicators

   # Set the data - the currency pair.
  def set_data(self, dataframe):
    self.df = dataframe.copy()
    self.__cur_pair = list(dataframe.columns)[0] #name of currency pair

	#set the database connect
  def set_database_conn(self, conn):
	  self.__db_conn = conn

  def rsi(self, top_threshold=80, bottom_threshold=20):
    """ use rsi, a momentum indicator measures the magnitude of recent price changes to evaluate overbought or oversold conditions.

    RSI > 70 -> Outbought, overvalued → trend reversal or corrective price pullback
    RSI < 30 -> Inbought, oversold → undervalued condition

    Args:
      top_threshold:
        overbuying signal at 70
      bottom_threshold:
        overselling signal at 30

    Returns:
      a dataframe with date index and a column contains trading signals based on RSI for the selected currency pair
    """
    if not 'rsi' in self.df.columns:
      print('dataframe not have rsi!')
      return None
    return self.df.rsi.apply(lambda x: 1 if x > top_threshold else -1 if x < bottom_threshold else 0).rename('rsi')

  #cci: spot long-term trend changes
  def cci(self, top_threshold=100, bottom_threshold=-100):
    """CCI strategy is used to track the CCI for movement above top_threshold, which generates buy signals,
       and movements below bottom_threshold, which generates sell or short trade signals
    Args:
      top_threshold:
        buying signal at 100
      bottom_threshold:
        selling signal at -100

    Returns:
        a dataframe with date index and a column contains trading signals based on CCI for the selected currency pair
      """
    if not 'cci' in self.df.columns:
      print('dataframe not have cci!')
      return pd.DataFrame()

    tmp = self.df.cci.apply(lambda x: 1 if x > top_threshold else -1 if x < bottom_threshold else 0)
    return tmp.rename('cci')

  # macd: a trend-following momentum indicator that shows the relationship between two moving averages of a security’s price.
  def macd(self, vol_threshold = 0.00004):
    """MACD indicates when should buy/sell by intersecting of macd line & signal line then combine with vol hist
    Args:
      vol_threshold:
    Returns:
        a dataframe with date index and a column contains trading signals based on MACD for the selected currency pair
      """
    lines = ['macd','macd_signal', 'macd_hist']
    tmp = self.df[lines[0]] - self.df[lines[1]]
    tmp = tmp.apply(lambda x: 1 if x > 0 else -1)
    hist = self.df[lines[2]].apply(lambda x : 1 if np.abs(x) >= vol_threshold else 0)
    tmp = tmp.mul(hist)
    return tmp.rename('macd')

  #ema: technical chart indicator that tracks the price of an investment (like a stock or commodity) over time.
  def ema(self):
    """ema: technical chart indicator that tracks the price of an investment (like a stock or commodity) over time.
    if price > SMA -> buy
       price < SMA -> sell
    Returns:
        a dataframe with date index and a column contains trading signals based on MACD for the selected currency pair
      """
    if not 'ema' in self.df.columns:
      print('dataframe not have ema!')
      return None

    tmp = self.df[self.__cur_pair] - self.df.ema
    tmp = tmp.apply(lambda x: 1 if x > 0 else -1)
    return tmp.rename('ema')

  # stochrsi: a technical indicator used to measure the strength and weakness of the relative strength indicator (RSI) over a set period of time
  def stochrsi(self, threshold = 50):
    """stochrsi: a technical indicator used to measure the strength and weakness of the relative strength indicator (RSI) over a set period of time
    Args:
      threshold:

    Returns:
        a dataframe with date index and a column contains trading signals for the selected currency pair
      """
    if not 'fast_d' in self.df.columns:
      print('dataframe not have fast_d!')
      return pd.DataFrame()

    tmp = self.df.fast_d.apply(lambda x: 1 if x > threshold else -1 if x < threshold else 0)
    return tmp.rename('stochrsi')

  # supertrend: trend following overlay on your trading chart, much like a moving average, that shows you the current trend direction
  def supertrend(self):
    """supertrend: trend following overlay on your trading chart, much like a moving average, that shows you the current trend direction
     Buy signal: when the supertrend closes above the price
     Sell signal: when the supertrend closes below the price.
    Returns:
        a dataframe with date index and a column contains trading signals for the selected currency pair
      """
    if not 'supertrend' in self.df.columns:
      print('dataframe not have supertrend!')
      return pd.DataFrame()

    tmp = self.df.supertrend.copy()
    for p, s, t in zip(self.df.close_price, self.df.supertrend, tmp):
      if s > p:
        x = 1
      elif s < p:
        x = -1
      else :
        x = 0
      t = x

    return tmp.rename('supertrend')


  # --- Moving Averages: Price Above Indicator Line -> Long Signal; Price Below Line -> Short Signal

  # SMA: Simple Moving Average
  # A simple moving average (SMA) calculates the average of a selected range of prices,
  # usually closing prices, by the number of periods in that range.
  def sma(self):
    """SMA: Simple Moving Average
    A simple moving average (SMA) calculates the average of a selected range of prices, usually closing prices, by the number of periods in that range.
    Returns:
        a dataframe with date index and a column contains trading signals for the selected currency pair
      """
    if not 'sma' in self.df.columns:
      print('dataframe not have sma!')
      return None

    tmp = self.df[self.__cur_pair] - self.df.sma
    tmp = tmp.apply(lambda x: 1 if x > 0 else -1)
    return tmp.rename('sma')

  # WMA:  Weighted Moving Average
  # The weighted moving average (WMA) is a technical indicator that assigns
  #  a greater weighting to the most recent data points, and less weighting to data points in the distant past.
  def wma(self):
    """ WMA:  Weighted Moving Average
     The weighted moving average (WMA) is a technical indicator that assigns
     a greater weighting to the most recent data points, and less weighting to data points in the distant past.
    Returns:
        a dataframe with date index and a column contains trading signals for the selected currency pair
      """
    if not 'wma' in self.df.columns:
      print('dataframe not have wma!')
      return None

    tmp = self.df[self.__cur_pair] - self.df.wma
    tmp = tmp.apply(lambda x: 1 if x > 0 else -1)
    return tmp.rename('wma')

  # VWAP: Volume Weighted Moving Average Price
  # The VWAP is a trading indicator, which averages the closing prices during the given time period.
  # At the same time, it puts emphasize on the periods with higher volume
  def vwap(self):
    """ VWAP: Volume Weighted Moving Average Price
     The VWAP is a trading indicator, which averages the closing prices during the given time period.
     At the same time, it puts emphasize on the periods with higher volume
    Returns:
        a dataframe with date index and a column contains trading signals for the selected currency pair
      """
    if not 'vwap' in self.df.columns:
      print('dataframe not have vwap!')
      return None

    tmp = self.df[self.__cur_pair] - self.df.vwap
    tmp = tmp.apply(lambda x: 1 if x > 0 else -1)
    return tmp.rename('vwap')


  #refactor
  def refactor(self, signals):
    """ adjust signals, for the same currency, if the next signal is the same as the previous signal, adjust the signal to hold

    Args:
      signals:
        dataframe contains signals for currency pair

    Returns:
      a dataframe with date index and a column contains trading adjusted signals
      """
    pre = 0
    for k,v in signals.iteritems():
      if v * pre > 0:
        signals[k] = 0
      if v != 0:
        pre = v
    return signals

  def plot_signal(self, close, signal, title="", size=(25,10), image_name = 'saved.png'):
    """ Plot the signal based on the indicators: red: sell, green: buy
    Args:
      close(dataframe, series): close price
      signal(dataframe, series): sequences of signal buy/sell
      """
    fig = plt.figure(figsize=size)

    ax =  fig.add_subplot(1,1,1)

    for t in signal.items():
      if t[1] == 1:
        ax.axvline(t[0], c='green', alpha=0.1)
      elif t[1] == -1:
        ax.axvline(t[0], c='red', alpha=0.1)
    plt.plot(close)
    plt.title(title)

    dir = "" + image_name
    fig.savefig(dir)
    return (fig)

	#-------------------------------------------
  def read_cur(self, cur_list, interval = '1h'):
    """store data from csv files into dictionary of dataframes
    Args:
        cur_list:
            list of currency pairs
    Returns:
        a dictionary of dataframes of historical prices and indicators for currency pairs
      """
    cur = {}
    for col in cur_list:
      cur[col] = self.get_crawled_data(pair = col)
      cur[col] = cur[col][~cur[col].index.duplicated(keep='first')]
    return cur


  def get_crawled_data(self, pair = "all"):
      """ Get the current crawled data from the database
      Parameters
      ----------

      pair: + default = all: Get data for all currency pair
            + pair: The chosen currency pair
      Returns
      -------
      The current crawled data occupied by the user


      Guidelines: data (index từ 0) = ['id,'currency_index', 'date', 'open_price', 'high_price', 'low_price', \
          'close_price', 'cci', 'macd', 'macd_signal', 'macd_hist', 'ema', 'rsi', 'fast_k', 'fast_d', 'supertrend', 'sma', 'wma', 'vwap']
      + Cách access: data[3] = column 'open_price'
      """

      conn = self.__db_conn
      cursor = conn.cursor()
      if pair != "all":
          query = "SELECT * FROM trading_data \
                          ORDER BY date DESC \
                          LIMIT 6000 ;"
          cursor.execute(query)
      else:
          query = "SELECT * FROM trading_data \
                          WHERE currency_index = (%s)\
                          ORDER BY date DESC \
                          LIMIT 1000 ;"
          cursor.execute(query, (pair))
          
      # Naturally we get a list of tupples
      tuples = cursor.fetchall()
      cursor.close()
      col = ['id','currency_index', 'date', 'open_price', 'high_price', 'low_price', 'close_price',
             'cci', 'macd', 'macd_signal', 'macd_hist', 'ema', 'rsi', 'fast_k', 'fast_d', 'supertrend', 'sma', 'wma', 'vwap']
      # We just need to turn it into a pandas dataframe
      df_prep= pd.DataFrame(tuples, columns=col)
      df = df_prep.iloc[:, 2:] # drop id and currency index column
      #df['date'] = df['date'].strftime("%Y-%m-%d %H:%M:%S") # parse date
      df['date'] = pd.to_datetime(df['date'])
      df = df.set_index('date') # set date as index
      print(df.head(2))
      return df


  def cur_analyze(self, cur, pair_name, indicators):
    """analyze selected currency pair based on the indicator and show price plot with signals and returns
      Args:
          cur:
              dictionary of currency pairs data
          pair_name:
              name of one currency pair needs to be analyzed
          indicators:
              list of technical indicators
      Returns:
          close price:
          signal:
          return: the return for currency pair from the signal

      """
    self.set_data(cur[pair_name])
    final_signals = pd.concat([self.get_indicators()[i]() for i in indicators], axis=1)
    close_price = self.df['close_price']
    count_indicators = len(indicators)
    
    #combine signals from the indicators
    final_signals = final_signals.sum(axis=1).apply(lambda x : 1 if x == count_indicators else -1 if -x == count_indicators else 0)
    
    # adjust the signals
    final_signals = self.refactor(final_signals)
    
    # plot the signals
    #plot_return = self.plot_signal(close_price, final_signals, size=(30, 8), image_name=pair_name.replace('/', '_') + '_' + str(count_indicators) + '.png')

    # calculate return
    returns = []
    index_mark = 0
    for k,v in final_signals.iteritems():
      if index_mark == 0:
        index_mark = k
        continue
      if v != 0:
        returns.append(final_signals.loc[k] * (1 - close_price.loc[k] / close_price.loc[index_mark]))
    return_cur =  np.mean(returns)

    return [close_price, final_signals, return_cur]

  #---------------------------------------------
  def optimize_portfolio(self, cur, indicator_list):
    #cur_list = np.array(['USD/AUD', 'USD/CAD', 'USD/CHF', 'USD/EUR', 'USD/GBP', 'USD/JPY', 'USD/NZD'])
    cur_list = np.array(['USD/AUD', 'USD/NZD'])
    pairs = self.read_cur(cur_list)
    result = self.cur_analyze(pairs, cur, indicator_list)
    return result
#--------------------------------endclass-----------------------------------------

Generator = IndicatorAnalyst()